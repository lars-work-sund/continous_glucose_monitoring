#' Filter missing data
#'
#' @param x a vector
#' @param idx logical
#' @param min_frac_summaries minimum average of idx
#'
#' @return x or NA
#'
#' @examples
#' \dontrun{
#' to-do
#' }
filter_max_missing <- function(x, idx, min_frac_summaries) {
  if (mean(idx) < min_frac_summaries) {
    return(NA)
  } else {
    return(x[idx])
  }
}

#' Get sample glucose statistics
#'
#' @param by character, columns to aggregate by
#' @param sample_data glucose monitoring data.table 
#' @param min_frac_summaries minimum fraction of included data for calculating summaries
#'
#' @return data.table with summaries
#' @import data.table
#' @export
#'
#' @examples
#' \dontrun{
#' to-do
#' }
glucose_statistics_sample <- function(by, sample_data, min_frac_summaries){
  # Silence no visible binding warnings
  tmp_included <- included <- Glucose <- . <- Sample_ID <- baseline <- High <- 
    Low <- Range <- nObservations <- NULL
  
  # Sometimes there will be datapoints that are included but does not have glucose values.
  # This leads to extra rows where everything is NA
  sample_data[, tmp_included:=(included) & !is.na(Glucose)]
  
  out <- sample_data[, .(
    Sample_ID = Sample_ID[[1]],
    nObservations = sum(tmp_included),
    `Mean Glucose` = as.numeric((mean <- mean(filter_max_missing(Glucose, tmp_included, min_frac_summaries), na.rm = TRUE))),
    SD = as.numeric((sd <- sd(filter_max_missing(Glucose, tmp_included, min_frac_summaries), na.rm = TRUE))),
    CV = as.numeric(mean/sd),
    SEM = as.numeric(sd/sqrt(length(filter_max_missing(Glucose, tmp_included, min_frac_summaries)))),
    Median = as.numeric(stats::median(filter_max_missing(Glucose, tmp_included, min_frac_summaries), na.rm = TRUE)),
    High = as.numeric((high <- max(filter_max_missing(Glucose, tmp_included, min_frac_summaries), na.rm = TRUE))),
    Low = as.numeric((low <- min(filter_max_missing(Glucose, tmp_included, min_frac_summaries), na.rm = TRUE))),
    Range = as.numeric(high - low),
    `25% quantile` = as.numeric((q25 <- stats::quantile(filter_max_missing(Glucose, tmp_included, min_frac_summaries), 0.25, na.rm = TRUE))),
    `75% quantile` = as.numeric((q75 <- stats::quantile(filter_max_missing(Glucose, tmp_included, min_frac_summaries), 0.75, na.rm = TRUE))),
    IQR = as.numeric(q75 - q25),
    `10% fractile` = as.numeric((q10 <- stats::quantile(filter_max_missing(Glucose, tmp_included, min_frac_summaries), 0.10, na.rm = TRUE))),
    `90% fractile` = as.numeric((q90 <- stats::quantile(filter_max_missing(Glucose, tmp_included, min_frac_summaries), 0.90, na.rm = TRUE))),
    `10% - 90% Range` = as.numeric(q90 - q10),
    `5% fractile` = as.numeric((q10 <- stats::quantile(filter_max_missing(Glucose, tmp_included, min_frac_summaries), 0.05, na.rm = TRUE))),
    `95% fractile` = as.numeric((q90 <- stats::quantile(filter_max_missing(Glucose, tmp_included, min_frac_summaries), 0.95, na.rm = TRUE))),
    Mean_Baseline = as.numeric(mean(filter_max_missing(baseline, tmp_included, min_frac_summaries), na.rm = TRUE)),
    SD_Baseline = as.numeric((sd_baseline <- sd(filter_max_missing(baseline, tmp_included, min_frac_summaries), na.rm = TRUE))),
    SEM_Baseline = as.numeric(sd_baseline/sqrt(length(filter_max_missing(Glucose, tmp_included, min_frac_summaries))))
  ),
  by = by]
  
  sample_data[, tmp_included:=NULL]
  #min and max returns -Inf instead of NA when no NA data is included
  out[is.infinite(High), High:=NA]
  out[is.infinite(Low), Low:=NA]
  out[is.infinite(Range), Range:=NA]
  
  #Sometimes groups with 0 observations sneak in
  out[nObservations > 0, ]
}

#' Get average glucose statistics
#'
#' @param by character, columns to aggregate by
#' @param sample_statistics list of results generated by glucose_statistics_sample
#'
#' @return data.table with summaries
#' @import data.table
#' @export
#'
#' @examples
#' \dontrun{
#' to-do
#' }
glucose_statistics_aggregate <- function(by, sample_statistics) {
  # Silence no visible binding warnings
  . <- nObservations <- `Mean Glucose` <- Median <- High <- Low <- Range <- 
    `25% quantile` <- `75% quantile` <- IQR <- `10% fractile` <- 
    `90% fractile` <- `10% - 90% Range` <- `5% fractile` <- `95% fractile` <- 
    Mean_Baseline <- SD_Baseline <- SEM_Baseline <- NULL
  sample_data <- do.call("rbind", sample_statistics)
  sample_data[, .(
    `Sample_ID` = "Average",
    `nObservations` = mean(nObservations, na.rm = TRUE),
    `Mean Glucose` = (mean <- mean(`Mean Glucose`, na.rm = TRUE)),
    `SD` = (sd <- sd(`Mean Glucose`, na.rm = TRUE)),
    `CV` = mean/sd,
    `SEM` = sd/sqrt(sum(!is.na(`Mean Glucose`))),
    `Median` = mean(Median, na.rm = TRUE),
    `High` = mean(High, na.rm = TRUE),
    `Low` = mean(Low, na.rm = TRUE),
    `Range` = mean(Range, na.rm = TRUE),
    `25% quantile` = mean(`25% quantile`, na.rm = TRUE),
    `75% quantile` = mean(`75% quantile`, na.rm = TRUE),
    `IQR` = mean(IQR, na.rm = TRUE),
    `10% fractile` = mean(`10% fractile`, na.rm = TRUE),
    `90% fractile` = mean(`90% fractile`, na.rm = TRUE),
    `10% - 90% Range` = mean(`10% - 90% Range`, na.rm = TRUE),
    `5% fractile` = mean(`5% fractile`, na.rm = TRUE),
    `95% fractile` = mean(`95% fractile`, na.rm = TRUE),
    `Mean_Baseline` = mean(Mean_Baseline, na.rm = TRUE),
    `SD_Baseline` = mean(SD_Baseline, na.rm = TRUE),
    `SEM_Baseline` = mean(SEM_Baseline, na.rm = TRUE)
  ),
  by = by]
}

#' Get glucose statistics
#'
#' @param cge cgm_experiment object
#'
#' @return data.table with summaries
#' @export
#'
#' @examples
#' \dontrun{
#' to-do
#' }
glucose_statistics <- function(cge){
  
  get_stats <- function(by, cge){
    statistics_sample <- lapply(cge$data, glucose_statistics_sample, by = by, min_frac_summaries = get_option(cge, "min_frac_summaries"))
    statistics_aggregate <- glucose_statistics_aggregate(by, statistics_sample)
    
    rbind(statistics_aggregate,
          do.call(what = "rbind", statistics_sample))
  }
  
  by_list <- stringr::str_split(get_option(cge, "summarize_by"), ";")[[1]]
  names(by_list) <- by_list
  by_list <- lapply(by_list, function(x) stringr::str_split(x, ",")[[1]])
  
  suppressWarnings(lapply(by_list, get_stats, cge))
}


#' Get sample peak statistics
#'
#' @param by character, columns to aggregate by
#' @param sample_data glucose monitoring data.table 
#' @param min_frac_summaries minimum fraction of included data for calculating summaries
#'
#' @return data.table with summaries
#' @import data.table
#' @export
#'
#' @examples
#' \dontrun{
#' to-do
#' }
peak_statistics_sample <- function(by, sample_data, min_frac_summaries){
  # Silence no visible binding warnings
  tmp_included <- included <- Glucose <- . <- Sample_ID <- peak <- nadir <- 
    excursion <- nObservations <- NULL
  
  # Sometimes there will be datapoints that are included but does not have glucose values.
  # This leads to extra rows where everything is NA
  sample_data[, tmp_included:=(included) & !is.na(Glucose)]
  
  out <- sample_data[, .(
    Sample_ID = Sample_ID[[1]],
    nObservations = (n_obs <- sum(tmp_included)),
    `Total peaks` = (totPeaks <- as.numeric(sum(filter_max_missing(peak, tmp_included, min_frac_summaries)))),
    `Total nadir` = (totNadir <- as.numeric(sum(filter_max_missing(nadir, tmp_included, min_frac_summaries)))),
    `MFGE(-)` = totNadir/(sum(tmp_included)/60),
    `MFGE(+)` = totPeaks/(sum(tmp_included)/60),
    `Total Hypo Time` = (tHypo <- as.numeric(sum(filter_max_missing(excursion, tmp_included, min_frac_summaries) < 0, na.rm = TRUE))),
    `Total Hyper Time` = (tHyper <- as.numeric(sum(filter_max_missing(excursion, tmp_included, min_frac_summaries) > 0, na.rm = TRUE))),
    `TIR-Low` = (tir_low <- tHypo/n_obs),
    `TIR-High` = (tir_high <- tHyper/n_obs),
    `TIR-Eq` = (1 - tir_low - tir_high),
    `MDGE(-)` = tHypo/totNadir,
    `MDGE(+)` = tHyper/totPeaks,
    `MAGE(-)` = (mageLow <- as.numeric(mean(filter_max_missing(excursion[nadir], tmp_included, min_frac_summaries), na.rm = TRUE))),
    `MAGE(+)` = (mageHigh <- as.numeric(mean(filter_max_missing(excursion[peak], tmp_included, min_frac_summaries), na.rm = TRUE))),
    `MAGE Range` = mageHigh - mageLow,
    `MVGE(-)` = (mvgeLow <- as.numeric(mean(filter_max_missing(excursion[excursion < 0], tmp_included, min_frac_summaries), na.rm = TRUE))),
    `MVGE(+)` = (mvgeHigh <- as.numeric(mean(filter_max_missing(excursion[excursion > 0], tmp_included, min_frac_summaries), na.rm = TRUE))),
    `MVGE Range` = mvgeHigh - mvgeLow
  ),
  by = by]
  sample_data[, tmp_included:=NULL]
  
  #Sometimes groups with 0 observations sneak in
  out[nObservations > 0, ]
}
  
#' Get average peak statistics
#'
#' @param by character, columns to aggregate by
#' @param sample_statistics list of results generated by peak_statistics_sample
#'
#' @return data.table with summaries
#' @import data.table
#' @export
#'
#' @examples
#' \dontrun{
#' to-do
#' }
peak_statistics_aggregate <- function(by, sample_statistics) {
  # Silence no visible binding warnings
  . <- nObservations <- `Total peaks` <- `Total nadir` <- `MFGE(-)` <- 
    `MFGE(+)` <- `Total Hypo Time` <- `Total Hyper Time` <- `TIR-Low` <- 
    `TIR-High` <- `TIR-Eq` <- `MDGE(-)` <- `MDGE(+)` <- `MAGE(-)` <- 
    `MAGE(+)` <- `MAGE Range` <- NULL
  sample_data <- do.call("rbind", sample_statistics)
  out <- sample_data[, .(
    `Sample_ID` = "Average",
    `nObservations` = mean(nObservations, na.rm = TRUE),
    `Total peaks` = mean(`Total peaks`, na.rm = TRUE),
    `Total nadir` = mean(`Total nadir`, na.rm = TRUE),
    `MFGE(-)` = mean(`MFGE(-)`, na.rm = TRUE),
    `MFGE(+)` = mean(`MFGE(+)`, na.rm = TRUE),
    `Total Hypo Time` = mean(`Total Hypo Time`, na.rm = TRUE),
    `Total Hyper Time` = mean(`Total Hyper Time`, na.rm = TRUE),
    `TIR-Low` = mean(`TIR-Low`, na.rm = TRUE),
    `TIR-High` = mean(`TIR-High`, na.rm = TRUE),
    `TIR-Eq` = mean(`TIR-Eq`, na.rm = TRUE),
    `MDGE(-)` = mean(`MDGE(-)`, na.rm = TRUE),
    `MDGE(+)` = mean(`MDGE(+)`, na.rm = TRUE),
    `MAGE(-)` = mean(`MAGE(-)`, na.rm = TRUE),
    `MAGE(+)` = mean(`MAGE(+)`, na.rm = TRUE),
    `MAGE Range` = mean(`MAGE Range`, na.rm = TRUE),
    `MVGE(-)` = mean(`MVGE(-)`, na.rm = TRUE),
    `MVGE(+)` = mean(`MVGE(+)`, na.rm = TRUE),
    `MVGE Range` = mean(`MVGE Range`, na.rm = TRUE)
  ),
  by = by]
  out
}

#' Get peak statistics
#'
#' @param cge cgm_experiment object
#'
#' @return data.table with summaries
#' @export
#'
#' @examples
#' \dontrun{
#' to-do
#' }
peak_statistics <- function(cge){
  get_stats <- function(by, cge){
    statistics_sample <- lapply(cge$data, peak_statistics_sample, by = by, min_frac_summaries = get_option(cge, "min_frac_summaries"))
    statistics_aggregate <- peak_statistics_aggregate(by, statistics_sample)
    
    rbind(statistics_aggregate,
          do.call(what = "rbind", statistics_sample))
  }
  
  by_list <- stringr::str_split(get_option(cge, "summarize_by"), ";")[[1]]
  names(by_list) <- by_list
  by_list <- lapply(by_list, function(x) stringr::str_split(x, ",")[[1]])
  
  suppressWarnings(lapply(by_list, get_stats, cge))
}







#' Get sample isoglycemic statistics
#'
#' @param by character, columns to aggregate by
#' @param sample_data glucose monitoring data.table 
#' @param min_frac_summaries minimum fraction of included data for calculating summaries
#'
#' @return data.table with summaries
#' @import data.table
#' @export
#'
#' @examples
#' \dontrun{
#' to-do
#' }
isoglycemic_statistics_sample <- function(by, sample_data, min_frac_summaries){
  # Silence no visible binding warnings
  tmp_included <- included <- Glucose <- iso_glucose <- baseline <- . <- 
    Sample_ID <- High <- Low <- Range <- nObservations <- NULL
  
  # Sometimes there will be datapoints that are included but does not have glucose values.
  # This leads to extra rows where everything is NA
  sample_data[, tmp_included:=(included) & !is.na(Glucose)]
  sample_data[, iso_glucose:=Glucose-baseline]
  
  out <- sample_data[, .(
    Sample_ID = Sample_ID[[1]],
    nObservations = sum(tmp_included),
    `Mean Isoglucose` = as.numeric((mean <- mean(filter_max_missing(iso_glucose, tmp_included, min_frac_summaries), na.rm = TRUE))),
    SD = as.numeric((sd <- sd(filter_max_missing(iso_glucose, tmp_included, min_frac_summaries), na.rm = TRUE))),
    CV = as.numeric(mean/sd),
    SEM = as.numeric(sd/sqrt(length(filter_max_missing(iso_glucose, tmp_included, min_frac_summaries)))),
    Median = as.numeric(stats::median(filter_max_missing(iso_glucose, tmp_included, min_frac_summaries), na.rm = TRUE)),
    High = as.numeric((high <- max(filter_max_missing(iso_glucose, tmp_included, min_frac_summaries), na.rm = TRUE))),
    Low = as.numeric((low <- min(filter_max_missing(iso_glucose, tmp_included, min_frac_summaries), na.rm = TRUE))),
    Range = as.numeric(high - low),
    `25% quantile` = as.numeric((q25 <- stats::quantile(filter_max_missing(iso_glucose, tmp_included, min_frac_summaries), 0.25, na.rm = TRUE))),
    `75% quantile` = as.numeric((q75 <- stats::quantile(filter_max_missing(iso_glucose, tmp_included, min_frac_summaries), 0.75, na.rm = TRUE))),
    IQR = as.numeric(q75 - q25),
    `10% fractile` = as.numeric((q10 <- stats::quantile(filter_max_missing(iso_glucose, tmp_included, min_frac_summaries), 0.10, na.rm = TRUE))),
    `90% fractile` = as.numeric((q90 <- stats::quantile(filter_max_missing(iso_glucose, tmp_included, min_frac_summaries), 0.90, na.rm = TRUE))),
    `10% - 90% Range` = as.numeric(q90 - q10),
    `5% fractile` = as.numeric((q10 <- stats::quantile(filter_max_missing(iso_glucose, tmp_included, min_frac_summaries), 0.05, na.rm = TRUE))),
    `95% fractile` = as.numeric((q90 <- stats::quantile(filter_max_missing(iso_glucose, tmp_included, min_frac_summaries), 0.95, na.rm = TRUE))),
    Mean_Baseline = as.numeric(mean(filter_max_missing(baseline, tmp_included, min_frac_summaries), na.rm = TRUE)),
    SD_Baseline = as.numeric((sd_baseline <- sd(filter_max_missing(baseline, tmp_included, min_frac_summaries), na.rm = TRUE))),
    SEM_Baseline = as.numeric(sd_baseline/sqrt(length(filter_max_missing(iso_glucose, tmp_included, min_frac_summaries))))
  ),
  by = by]
  
  sample_data[, tmp_included:=NULL]
  sample_data[, iso_glucose:=NULL]
  #min and max returns -Inf instead of NA when no NA data is included
  out[is.infinite(High), High:=NA]
  out[is.infinite(Low), Low:=NA]
  out[is.infinite(Range), Range:=NA]
  
  #Sometimes groups with 0 observations sneak in
  out[nObservations > 0, ]
}

#' Get average isoglycemic statistics
#'
#' @param by character, columns to aggregate by
#' @param sample_statistics list of results generated by glucose_statistics_sample
#'
#' @return data.table with summaries
#' @import data.table
#' @export
#'
#' @examples
#' \dontrun{
#' to-do
#' }
isoglycemic_statistics_aggregate <- function(by, sample_statistics) {
  # Silence no visible binding warnings
  . <- nObservations <- `Mean Isoglucose` <- Median <- High <- Low <- Range <- 
    `25% quantile` <- `75% quantile` <- IQR <- `10% fractile` <- 
    `90% fractile` <- `10% - 90% Range` <- `5% fractile` <- `95% fractile` <- 
    Mean_Baseline <- SD_Baseline <- SEM_Baseline <- NULL
  
  sample_data <- do.call("rbind", sample_statistics)
  sample_data[, .(
    `Sample_ID` = "Average",
    `nObservations` = mean(nObservations, na.rm = TRUE),
    `Mean Isoglucose` = (mean <- mean(`Mean Isoglucose`, na.rm = TRUE)),
    `SD` = (sd <- sd(`Mean Isoglucose`, na.rm = TRUE)),
    `CV` = mean/sd,
    `SEM` = sd/sqrt(sum(!is.na(`Mean Isoglucose`))),
    `Median` = mean(Median, na.rm = TRUE),
    `High` = mean(High, na.rm = TRUE),
    `Low` = mean(Low, na.rm = TRUE),
    `Range` = mean(Range, na.rm = TRUE),
    `25% quantile` = mean(`25% quantile`, na.rm = TRUE),
    `75% quantile` = mean(`75% quantile`, na.rm = TRUE),
    `IQR` = mean(IQR, na.rm = TRUE),
    `10% fractile` = mean(`10% fractile`, na.rm = TRUE),
    `90% fractile` = mean(`90% fractile`, na.rm = TRUE),
    `10% - 90% Range` = mean(`10% - 90% Range`, na.rm = TRUE),
    `5% fractile` = mean(`5% fractile`, na.rm = TRUE),
    `95% fractile` = mean(`95% fractile`, na.rm = TRUE),
    `Mean_Baseline` = mean(Mean_Baseline, na.rm = TRUE),
    `SD_Baseline` = mean(SD_Baseline, na.rm = TRUE),
    `SEM_Baseline` = mean(SEM_Baseline, na.rm = TRUE)
  ),
  by = by]
}

#' Get isoglycemic statistics
#'
#' @param cge cgm_experiment object
#'
#' @return data.table with summaries
#' @export
#'
#' @examples
#' \dontrun{
#' to-do
#' }
isoglycemic_statistics <- function(cge){
  
  get_stats <- function(by, cge){
    statistics_sample <- lapply(cge$data, isoglycemic_statistics_sample, by = by, min_frac_summaries = get_option(cge, "min_frac_summaries"))
    statistics_aggregate <- isoglycemic_statistics_aggregate(by, sample_statistics = statistics_sample)
    
    rbind(statistics_aggregate,
          do.call(what = "rbind", statistics_sample))
  }
  
  by_list <- stringr::str_split(get_option(cge, "summarize_by"), ";")[[1]]
  names(by_list) <- by_list
  by_list <- lapply(by_list, function(x) stringr::str_split(x, ",")[[1]])
  
  suppressWarnings(lapply(by_list, get_stats, cge))
}

#' Get sample temperature/activity statistics
#'
#' @param by character, columns to aggregate by
#' @param sample_data glucose monitoring data.table 
#' @param min_frac_summaries minimum fraction of included data for calculating summaries
#' @param column column to be summarized. Tested with Activity and Temperature
#'
#' @return data.table with summaries
#' @import data.table
#' @export
#'
#' @examples
#' \dontrun{
#' to-do
#' }
other_statistics_sample <- function(by, sample_data, min_frac_summaries, column){
  # Silence no visible binding warnings
  tmp_included <- included <- . <- Sample_ID <- High <- Low <- Range <- 
    nObservations <- NULL
  
  # Sometimes there will be datapoints that are included but does not have values.
  # This leads to extra rows where everything is NA
  sample_data[, tmp_included:=(included) & !is.na(eval(column))]
  
  out <- sample_data[, .(
    Sample_ID = Sample_ID[[1]],
    nObservations = sum(tmp_included),
    `Mean Value` = as.numeric((mean <- mean(filter_max_missing(eval(column), tmp_included, min_frac_summaries), na.rm = TRUE))),
    SD = as.numeric((sd <- sd(filter_max_missing(eval(column), tmp_included, min_frac_summaries), na.rm = TRUE))),
    CV = as.numeric(mean/sd),
    SEM = as.numeric(sd/sqrt(length(filter_max_missing(eval(column), tmp_included, min_frac_summaries)))),
    Median = as.numeric(stats::median(filter_max_missing(eval(column), tmp_included, min_frac_summaries), na.rm = TRUE)),
    High = as.numeric((high <- max(filter_max_missing(eval(column), tmp_included, min_frac_summaries), na.rm = TRUE))),
    Low = as.numeric((low <- min(filter_max_missing(eval(column), tmp_included, min_frac_summaries), na.rm = TRUE))),
    Range = as.numeric(high - low),
    `25% quantile` = as.numeric((q25 <- stats::quantile(filter_max_missing(eval(column), tmp_included, min_frac_summaries), 0.25, na.rm = TRUE))),
    `75% quantile` = as.numeric((q75 <- stats::quantile(filter_max_missing(eval(column), tmp_included, min_frac_summaries), 0.75, na.rm = TRUE))),
    IQR = as.numeric(q75 - q25),
    `10% fractile` = as.numeric((q10 <- stats::quantile(filter_max_missing(eval(column), tmp_included, min_frac_summaries), 0.10, na.rm = TRUE))),
    `90% fractile` = as.numeric((q90 <- stats::quantile(filter_max_missing(eval(column), tmp_included, min_frac_summaries), 0.90, na.rm = TRUE))),
    `10% - 90% Range` = as.numeric(q90 - q10),
    `5% fractile` = as.numeric((q10 <- stats::quantile(filter_max_missing(eval(column), tmp_included, min_frac_summaries), 0.05, na.rm = TRUE))),
    `95% fractile` = as.numeric((q90 <- stats::quantile(filter_max_missing(eval(column), tmp_included, min_frac_summaries), 0.95, na.rm = TRUE)))
  ),
  by = by]
  
  sample_data[, tmp_included:=NULL]
  #min and max returns -Inf instead of NA when no NA data is included
  out[is.infinite(High), High:=NA]
  out[is.infinite(Low), Low:=NA]
  out[is.infinite(Range), Range:=NA]
  
  #Sometimes groups with 0 observations sneak in
  out[nObservations > 0, ]
}

#' Get average temperature/activity statistics
#'
#' @param by character, columns to aggregate by
#' @param sample_statistics list of results generated by glucose_statistics_sample
#'
#' @return data.table with summaries
#' @import data.table
#' @export
#'
#' @examples
#' \dontrun{
#' to-do
#' }
other_statistics_aggregate <- function(by, sample_statistics) {
  # Silence no visible binding warnings
  . <- nObservations <- `Mean Value` <- Median <- High <- Low <- Range <- 
    `25% quantile` <- `75% quantile` <- IQR <- `10% fractile` <- 
    `90% fractile` <- `10% - 90% Range` <- `5% fractile` <- `95% fractile` <- NULL
  
  sample_data <- do.call("rbind", sample_statistics)
  out <- sample_data[, .(
    `Sample_ID` = "Average",
    `nObservations` = mean(nObservations, na.rm = TRUE),
    `Mean Value` = (mean <- mean(`Mean Value`, na.rm = TRUE)),
    `SD` = (sd <- sd(`Mean Value`, na.rm = TRUE)),
    `CV` = mean/sd,
    `SEM` = sd/sqrt(sum(!is.na(`Mean Value`))),
    `Median` = mean(Median, na.rm = TRUE),
    `High` = mean(High, na.rm = TRUE),
    `Low` = mean(Low, na.rm = TRUE),
    `Range` = mean(Range, na.rm = TRUE),
    `25% quantile` = mean(`25% quantile`, na.rm = TRUE),
    `75% quantile` = mean(`75% quantile`, na.rm = TRUE),
    `IQR` = mean(IQR, na.rm = TRUE),
    `10% fractile` = mean(`10% fractile`, na.rm = TRUE),
    `90% fractile` = mean(`90% fractile`, na.rm = TRUE),
    `10% - 90% Range` = mean(`10% - 90% Range`, na.rm = TRUE),
    `5% fractile` = mean(`5% fractile`, na.rm = TRUE),
    `95% fractile` = mean(`95% fractile`, na.rm = TRUE)
  ),
  by = by]

  out[]
}

#' Get temperature/activity statistics
#'
#' @param cge cgm_experiment object
#' @param column column to be summarized. Tested with Activity and Temperature
#'
#' @return data.table with summaries
#' @export
#'
#' @examples
#' \dontrun{
#' to-do
#' }
other_statistics <- function(cge, column){
  column <- substitute(column)
  get_stats <- function(by, cge){
    statistics_sample <- lapply(cge$data, other_statistics_sample, by = by, 
                                min_frac_summaries = get_option(cge, "min_frac_summaries"), 
                                column = column)
    statistics_aggregate <- other_statistics_aggregate(by, statistics_sample)
    
    out <- data.table::rbindlist(c(list(statistics_aggregate), statistics_sample))
    data.table::setnames(out, "Mean Value", paste0("Mean ", as.character(column)))
  }
  
  by_list <- stringr::str_split(get_option(cge, "summarize_by"), ";")[[1]]
  names(by_list) <- by_list
  by_list <- lapply(by_list, function(x) stringr::str_split(x, ",")[[1]])
  
  suppressWarnings(lapply(by_list, get_stats, cge))
}

#' Get counts of kinetics observations
#'
#' @param by character, columns to aggregate by
#' @param kinetics table with kinetics data
#'
#' @return data.table with number kinetics observations
#' @import data.table
#' @export
#'
#' @examples
#' \dontrun{
#' to-do
#' }
kinetics_counts_single <- function(by, kinetics){
  # Silence no visible binding warnings
  . <- peak_type <- NULL
  out <- kinetics[, .(
    n_Observations = .N,
    n_Single = sum(peak_type == "Single"),
    n_First = sum(peak_type == "First"),
    n_Internal = sum(peak_type == "Internal"),
    n_Last = sum(peak_type == "Last")
  ), 
  by = by]
  out[]
}

#' Get statistics on kinetics parameters
#'
#' @param by character, columns to aggregate by
#' @param column column to calculate statistics on
#' @param kinetics table with kinetics data
#'
#' @return data.table with kinetics summaries
#' @import data.table
#' @export
#'
#' @examples
#' \dontrun{
#' to-do
#' }
kinetics_statistics_single <- function(by, column, kinetics){
  # Silence no visible binding warnings
  . <- NULL
  column <- substitute(column)
  out <- kinetics[, .(
    Mean = as.numeric(mean(eval(column), na.rm = TRUE)),
    SD = as.numeric((sd <- sd(eval(column), na.rm = TRUE))),
    SEM = as.numeric(sd/sqrt(sum(!is.na(eval(column)))))
  ), 
  by = by]
  setnames(out, c("Mean", "SD", "SEM"), paste0(as.character(column), c("_Mean", "_SD", "_SEM")))
  out[]
}

#' Get kinetics statistics
#'
#' @param cge cgm_experiment object
#'
#' @return data.table with summaries
#' @import data.table
#' @export
#'
#' @examples
#' \dontrun{
#' to-do
#' }
kinetics_statistics <- function(cge){
  # Silence no visible binding warnings
  peak_type <- mean_uptake <- mean_clearance <- excursion_duration <- 
    excursion_duration <- area_under_excursion <- mean_uptake <- mean_clearance <- 
    max_uptake <- max_clearance <- uptakeSpring <- clearanceSpring <- NULL
  
  kinetics <- copy(cge$kinetics)
  
  kinetics[!(peak_type %in% c("Single", "First")), mean_uptake:=NA] # Should already be the case
  kinetics[!(peak_type %in% c("Single", "Last")), mean_clearance:=NA] # Should already be the case
  kinetics[!(peak_type %in% c("Single", "First")), excursion_duration:=NA] # To avoid counting multi-peaks multiple times
  
  get_stats <- function(by){
    all_stats <- list(
      counts = kinetics_counts_single(by, kinetics),
      excursion_duration = kinetics_statistics_single(by, excursion_duration, kinetics),
      area_under_excursion = kinetics_statistics_single(by, area_under_excursion , kinetics),
      mean_uptake = kinetics_statistics_single(by, mean_uptake, kinetics),
      mean_clearance = kinetics_statistics_single(by, mean_clearance, kinetics),
      max_uptake = kinetics_statistics_single(by, max_uptake, kinetics),
      max_clearance = kinetics_statistics_single(by, max_clearance, kinetics),
      uptakeSpring = kinetics_statistics_single(by, uptakeSpring, kinetics),
      clearanceSpring = kinetics_statistics_single(by, clearanceSpring, kinetics)
    )
    setnames(all_stats[["mean_uptake"]], stringr::str_replace(colnames(all_stats[["mean_uptake"]]), "mean_uptake", "mean_uptake_Single_First"))
    setnames(all_stats[["mean_clearance"]], stringr::str_replace(colnames(all_stats[["mean_clearance"]]), "mean_clearance", "mean_clearance_Single_Last"))
    
    merger <- function(x, y) merge.data.table(x, y, by = by)
    
    Reduce(merger, all_stats)
  }
  
  by_list <- stringr::str_split(get_option(cge, "summarize_by"), ";")[[1]]
  names(by_list) <- by_list
  by_list <- lapply(by_list, function(x) stringr::str_split(x, ",")[[1]])
  
  suppressWarnings(lapply(by_list, get_stats))
}
